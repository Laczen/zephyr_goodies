/*
 * Copyright (c) 2024 Laczen
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @file
 * @brief Public API for storage area subsystem
 *
 * The storage area API is a subsystem that creates a unified method to work
 * with flash, eeprom, ram, disks, files, ... for storage. A storage area is
 * an area that has a number of constant sized erase blocks, and has constant
 * write block size. The storage area does not necessarily inherit the
 * limitations of the underlying storage device but rather defines a method of
 * how the underlying storage device will be used (however it does not remove
 * any limitations of the underlying storage device). A storage area can be
 * defined with wrong properties, optionally the definition will be checked
 * by defining the Kconfig option `CONFIG_STORAGE_AREA_VERIFY` that is by
 * default enabled for `DEBUG` builds.
 *
 *
 * There following methods are exposed:
 *   storage_area_read(),	** read data **
 *   storage_area_readv(),	** read data vector **
 *   storage_area_write(),	** write data **
 *   storage_area_writev(),	** write data vector **
 *   storage_area_erase(),	** erase (in erase block addressing) **
 *   storage_area_ioctl()	** used for e.g. getting xip addresses **
 *
 * The subsystem is easy extendable to create custom (virtual) storage areas
 * that consist of e.g. a combination of flash and ram, an encrypted storage
 * area, ...
 *
 * A storage area is defined e.g. for flash:
 * struct storage_area_flash fa =
 *	flash_storage_area(dev, start, xip_address, write_size, erase_size,
 *			   size, properties);
 * struct storage_area *area = &fa.area;
 *
 * For other storage devices (eeprom, ram, disk, ...) similar macros are
 * defines, but they might differ slightly.
 *
 * The write_size, erase_size, ... are declarations of how the storage_area
 * will be used The write_size is limited to a power of 2, erase_size should
 * be a multiple of write_size and size should be a multiple of erase_size.
 * The macro definitions xxxxx_storage_area(...) checks these conditions but
 * always succeeds. Trying to use a badly sized storage area will result in
 * failure of any of the exposed methods.
 *
 */

#ifndef ZEPHYR_INCLUDE_STORAGE_STORAGE_AREA_H_
#define ZEPHYR_INCLUDE_STORAGE_STORAGE_AREA_H_

#include <stdint.h>
#include <stddef.h>
#include <sys/types.h>
#include <zephyr/sys/util.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Storage_area interface
 * @defgroup storage_area_interface Storage_area interface
 * @ingroup storage_apis
 * @{
 */

/* Allow the sa_off_t type to be redefined if needed */
typedef off_t sa_off_t;

struct storage_area;

struct storage_area_iovec { /* storage area io vector */
	void *data;         /* pointer to data */
	size_t len;         /* data length */
};

enum storage_area_properties_mask {
	STORAGE_AREA_PROP_READONLY = BIT(0),
	STORAGE_AREA_PROP_FOVRWRITE = BIT(1), /* full overwrite (ram, rram, ...) */
	STORAGE_AREA_PROP_LOVRWRITE = BIT(2), /* limited overwrite (nor flash) */
	STORAGE_AREA_PROP_ZEROERASE = BIT(3), /* erased value is 0x00 */
	STORAGE_AREA_PROP_AUTOERASE = BIT(4), /* erase while writing */
};

enum storage_area_ioctl_cmd {
	STORAGE_AREA_IOCTL_NONE,
	STORAGE_AREA_IOCTL_XIPADDRESS, /* retrieve the storage area xip address */
};

/**
 * @brief storage_area API
 *
 * API to access storage area.
 */
struct storage_area_api {
	int (*readv)(const struct storage_area *area, sa_off_t offset,
		     const struct storage_area_iovec *iovec, size_t iovcnt);
	int (*writev)(const struct storage_area *area, sa_off_t offset,
		    const struct storage_area_iovec *iovec, size_t iovcnt);
	int (*erase)(const struct storage_area *area, size_t sblk, size_t bcnt);
	int (*ioctl)(const struct storage_area *area,
		     enum storage_area_ioctl_cmd cmd, void *data);
};

/**
 * @brief storage_area struct
 */
struct storage_area {
	const struct storage_area_api *api;
	size_t write_size;
	size_t erase_size;
	size_t erase_blocks;
	uint32_t props; /* bitfield of storage area properties */
};

/**
 * @brief storage_area macros
 */
#define STORAGE_AREA_HAS_PROPERTY(area, prop) ((area->props & prop) == prop)
#define STORAGE_AREA_WRITESIZE(area)          area->write_size
#define STORAGE_AREA_ERASESIZE(area)          area->erase_size
#define STORAGE_AREA_SIZE(area)							\
	(area->erase_size * area->erase_blocks)
#define STORAGE_AREA_READONLY(area)                                             \
	STORAGE_AREA_HAS_PROPERTY(area, STORAGE_AREA_PROP_READONLY)
#define STORAGE_AREA_FOVRWRITE(area)                                            \
	STORAGE_AREA_HAS_PROPERTY(area, STORAGE_AREA_PROP_FOVRWRITE)
#define STORAGE_AREA_LOVRWRITE(area)                                            \
	STORAGE_AREA_HAS_PROPERTY(area, STORAGE_AREA_PROP_LOVRWRITE)
#define STORAGE_AREA_ERASEVALUE(area)                                           \
	STORAGE_AREA_HAS_PROPERTY(area, STORAGE_AREA_PROP_ZEROERASE) ?		\
	0x00 : 0xff
#define STORAGE_AREA_AUTOERASE(area)						\
	STORAGE_AREA_HAS_PROPERTY(area, STORAGE_AREA_PROP_AUTOERASE)

#define GET_STORAGE_AREA(_name)							\
	(struct storage_area *)&_storage_area_##_name.area
/**
 * @brief	 Read iovec from storage area.
 *
 * @param area   storage area.
 * @param offset offset in storage area (byte).
 * @param iovec  io vector for read.
 * @param iovcnt iovec element count.
 *
 * @retval	 0 on success else negative errno code.
 */
int storage_area_readv(const struct storage_area *area, sa_off_t offset,
		       const struct storage_area_iovec *iovec, size_t iovcnt);

/**
 * @brief	 Read from storage area.
 *
 * @param area	 storage area.
 * @param offset offset in storage area (byte).
 * @param data	 data.
 * @param len    read size.
 *
 * @retval	 0 on success else negative errno code.
 */
int storage_area_read(const struct storage_area *area, sa_off_t offset,
		      void *data, size_t len);

/**
 * @brief	 Write iovec to storage area.
 *
 * @param area	 storage area.
 * @param offset offset in storage area (byte).
 * @param iovec	 io vector to write.
 * @param iovcnt iovec element count.
 *
 * @retval	 0 on success else negative errno code.
 */
int storage_area_writev(const struct storage_area *area, sa_off_t offset,
			const struct storage_area_iovec *iovec, size_t iovcnt);

/**
 * @brief	 Write data to storage area.
 *
 * @param area	 storage area.
 * @param offset offset in storage area (byte).
 * @param data	 data to program.
 * @param len    program size.
 *
 * @retval	 0 on success else negative errno code.
 */
int storage_area_write(const struct storage_area *area, sa_off_t offset,
		       const void *data, size_t len);

/**
 * @brief      Erase storage area.
 *
 * @param area storage area.
 * @param sblk start block
 * @param bcnt number of blocks to erase.
 *
 * @retval     0 on success else negative errno code.
 */
int storage_area_erase(const struct storage_area *area, size_t sblk,
		       size_t bcnt);

/**
 * @brief	Storage area ioctl.
 *
 * @param area	storage area.
 * @param cmd	ioctl command.
 * @param data	in/out data pointer.
 *
 * @retval	0 on success else negative errno code.
 */
int storage_area_ioctl(const struct storage_area *area,
		       enum storage_area_ioctl_cmd cmd, void *data);

/**
 * @}
 */

#ifdef __cplusplus
}
#endif

#endif /* ZEPHYR_INCLUDE_STORAGE_STORAGE_AREA_H_ */
